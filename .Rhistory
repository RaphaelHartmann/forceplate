trial.info <- list(onset = event.info$onset[tmp.ind] - round(samp.factor*start.prepend))
trial.info$offset <- c(tail(trial.info$onset, -1), nrow(tmp.dt))
trial.ind <- vec_seq(trial.info$onset, trial.info$offset, 1)
for (j in 1:length(trial.ind)) {
tmp.trial.dt <- copy(tmp.dt[trial.ind[[j]]])
bioware.trial.list[[j]] <- tmp.trial.dt
}
# CONDITIONS
condition.info <- lapply(cond.trigger.list, FUN = function(x) {
event.info$values[which(event.info$values %in% x)]
})
bioware.dt[, names(condition.info) := condition.info]
# RESPONSE AND RESPONSE TIME
# --- # --- # assuming usually all trials have the same number of triggers in it
tmp.ind <- which(event.info$values %in% respone.trigger)
response.info <- list(onset = event.info$onset[tmp.ind-1])
response.info$offset <- event.info$onset[tmp.ind] - 1
if (length(tmp.ind) == num.trials) {
bioware.dt[, response := event.info$values[tmp.ind]]
bioware.dt[, rt := (response.info$offset - response.info$onset)/samp.factor]
} else {
n.missing <- num.trials - length(tmp.ind)
tmp.ind2 <- which(event.info$values %in% start.trigger)
tmp.diff <- c(NaN, diff(tmp.ind2))
tmp.fail <- unique(sort(tmp.diff))[which(table(tmp.diff)==n.missing)]
tmp.fail.ind <- which(tmp.diff==tmp.fail)
bioware.dt[-tmp.fail.ind, response := event.info$values[tmp.ind]]
bioware.dt[-tmp.fail.ind, rt := (response.info$offset - response.info$onset)/samp.factor]
}
# BASELINE CORRECTION
if (baseline.trigger >= 1) {
tmp.ind <- which(event.info$values %in% baseline.trigger)
baseline.info <- list(zero = event.info$onset[tmp.ind])
if (is.null(baseline.intv)) {
baseline.info$lower <- baseline.info$zero
baseline.info$upper <- event.info$onset[tmp.ind+1] - 1
} else {
baseline.info$lower <- baseline.info$zero + round(samp.factor*baseline.intv[1])
baseline.info$upper <- baseline.info$zero + round(samp.factor*baseline.intv[2])
}
baseline.ind <- vec_seq(baseline.info$lower, baseline.info$upper, 1)
crossings <- unique(tmp.dt$events[unlist(baseline.ind)])
if (any(!(crossings %in% c(0, baseline.trigger)))) {
warning(paste0("when using the baseline.intv the following triggers were crossed: ", paste0(crossings[which(!(crossings %in% c(0, baseline.trigger)))], collapse = ", ")))
}
means <- lapply(baseline.ind, function(rows) {
tmp.dt[rows, lapply(.SD, mean), .SDcols = cols]
})
meansdiff <- lapply(baseline.ind, function(rows) {
tmp.dt[rows, lapply(.SD, FUN = function(x) mean(diff(x))), .SDcols = c("CoPx", "CoPy")]
})
for (j in 1:length(trial.ind)) {
bioware.trial.list[[j]][, c("dCoPx", "dCoPy") := .(c(diff(CoPx), NaN), c(diff(CoPy), NaN))]
bioware.trial.list[[j]][, c("dCoPx", "dCoPy") := .(dCoPx - meansdiff[[j]]$CoPx, dCoPy - meansdiff[[j]]$CoPy)]
bioware.trial.list[[j]][, c("Fx", "Fy", "Mx", "My", "Mz", "CoPx", "CoPy") := .(Fx - means[[j]]$Fx, Fy - means[[j]]$Fy,
Mx - means[[j]]$Mx, My - means[[j]]$My, Mz - means[[j]]$Mz,
CoPx - means[[j]]$CoPx, CoPy - means[[j]]$CoPy)]
setnames(bioware.trial.list[[j]], c(cols, "dCoPx", "dCoPy"), c(colsnew, "dCoPx_bc", "dCoPy_bc"))
bioware.dt$bioware[[j]] <- bioware.trial.list[[j]]
}
}
# TIME LOCKING
# NOTE: just calculate for each trial how many data points need to
#   be before and after such that the time lock is at the
#   desired location
# NOTE2: maybe take bioware.trial.list and change that
#   and then add all to bioware.dt
# SAVE DATA.TABLE IN LARGE A LIST
list.bioware.dt[[i]] <- bioware.dt
}
bioware.dt
devtools::load_all(".")
dt_psypy <- data.table::fread("/home/fluffy/Documents/R4Kraftmessplatte/R-pkg/forceplate/inst/extdata/subj099.csv")
dt_psypy
dt_psypy$blocks_loop.thisN
as.numeric(gsub(".*block([0-9]+).*", "\\1", "block000"))
final.dt.psypy <- prep_psychopy(filenames = "/home/fluffy/Documents/R4Kraftmessplatte/R-pkg/forceplate/inst/extdata/subj099.csv", na.strings = c("[]", "None"), excl.vars = 1:4)
final.dt.psypy
final.dt.psypy
final.dt.psypy$Correct_key
final.dt.psypy$button_resp.keys
list.bioware.dt
final.dt.psypy$button_resp.keys
669 %/% 80
669 %% 80
which(final.dt.psypy$button_resp.keys == NA)
which(is.na(final.dt.psypy$button_resp.keys))
which(is.na(final.dt.psypy$button_resp.keys)) %/% 80
which(is.na(final.dt.psypy$button_resp.keys)) %% 80
data.table::rbindlist(list.bioware.dt)
dt.bw <- data.table::rbindlist(list.bioware.dt)
dt.bw$rt
final.dt.psypy$button_resp.rt
dt.bw$rt-final.dt.psypy$button_resp.rt
final.dt.psypy$button_resp.rt
dt.bw$rt-final.dt.psypy$button_resp.rt*1000
mean(dt.bw$rt-final.dt.psypy$button_resp.rt*1000, na.rm = TRUE)
data.table::data.table(bw = dt.bw$response, pp = final.dt.psypy$button_resp.keys)
data.table::data.table(bw = dt.bw$response, pp = final.dt.psypy$keyEnd_experiment.corr)
data.table::data.table(bw = dt.bw$response, pp = final.dt.psypy$button_resp.keys)
data.table::data.table(bw = dt.bw$response, pp = final.dt.psypy$keyBlock_start.keys)
data.table::data.table(bw = dt.bw$response, pp = final.dt.psypy$button_resp.keys)
head(data.table::data.table(bw = dt.bw$response, pp = final.dt.psypy$button_resp.keys), 20)
head(data.table::data.table(bw = dt.bw$response, pp = final.dt.psypy$Correct_key), 20)
data.table(dt.bw$rt-final.dt.psypy$button_resp.rt*1000)
diff <- dt.bw$rt-final.dt.psypy$button_resp.rt*1000
hist(diff)
final.dt.psypy$blocks_loop.thisN
dt.bw$block
final.dt.psypy$blocks_loop.thisN+1
View(dt.bw)
View(final.dt.psypy)
head(data.table::data.table(bw = dt.bw$location, pp = final.dt.psypy$Parallel_signal), 20)
head(data.table::data.table(bw = dt.bw$response, pp = final.dt.psypy$button_resp.corr), 20)
tail(data.table::data.table(bw = dt.bw$response, pp = final.dt.psypy$button_resp.corr), 20)
tail(data.table::data.table(bw = dt.bw$response, pp = final.dt.psypy$button_resp.corr), 30)
tail(data.table::data.table(bw = dt.bw$response, pp = final.dt.psypy$button_resp.corr), 50)
tail(data.table::data.table(bw = dt.bw$rt, pp = final.dt.psypy$button_resp.rt), 50)
event.info$values
# RESPONSE AND RESPONSE TIME
# --- # --- # assuming usually all trials have the same number of triggers in it
tmp.ind <- which(event.info$values %in% respone.trigger)
tmp.ind
num.trials <- n.trials[10]
i
num.trials <- n.trials[i]
# READ IN FILE BY NAME (AND GET PORT INDICES)
port.ind <- NULL
tmp.col.names <- NULL
if (is.null(col.names)){
tmp.col.names <- colnames(fread(filenames[i], skip = skip-2, nrows = 1))
if(any(tmp.col.names == "aux")) {
port.ind <- which(tmp.col.names == "aux")
tmp.col.names[port.ind] <- paste0("port", 1:length(port.ind))
}
}
tmp.dt <- fread(filenames[i], na.strings = na.strings, skip = skip, col.names = tmp.col.names)
# COMPUTE SOME VARIABLES
tmp.dt[, CoPx:=(Fx*az0 - My*1000)/(Fz)]
tmp.dt[, CoPy:=(Fy*az0 + Mx*1000)/(Fz)]
tmp.dt[, Tz_new:=(Mz)*1000 - (Fy)*(CoPx) + (Fx)*(CoPy)]
# CALCULATE EVENTS BY TRANSFORMATION OF PORT AND BYTE TO DECIMAL
byte <- tmp.dt[, lapply(.SD, function(x) x > 1.5), .SDcols = port.ind]
tmp.dt[, events := event_encoder(byte = byte, port.ind = port.ind)]
rm(byte); gc()
# PREPARE CONDITIONS FOR BIOWARE DATA.TABLE
cond.names <- names(cond.trigger.list)
# CREATE DATA.TABLE FOR THE CURRENT BLOCK
bioware.dt <- data.table(subj = fn.info$subjNR[i], block = fn.info$blockNR[i],
trial = 1:num.trials, bioware = list())
bioware.dt[, c(cond.names) := .(NA)]
bioware.dt <- bioware.dt[, c(1:3, 4+(1:length(cond.names)), 4), with = FALSE]
# CREATE LIST FOR DATA.TABLE OBJECTS PER TRIAL
bioware.trial.list <- vector(mode = "list", length = num.trials)
# CREATE ON- AND OFFSETS FOR EACH TRIGGER AND CLEAN
event.info <- event_transcription(dt = tmp.dt)
# PREPARE SEGMENTATION
tmp.ind <- which(event.info$values %in% start.trigger)
trial.info <- list(onset = event.info$onset[tmp.ind] - round(samp.factor*start.prepend))
trial.info$offset <- c(tail(trial.info$onset, -1), nrow(tmp.dt))
trial.ind <- vec_seq(trial.info$onset, trial.info$offset, 1)
for (j in 1:length(trial.ind)) {
tmp.trial.dt <- copy(tmp.dt[trial.ind[[j]]])
bioware.trial.list[[j]] <- tmp.trial.dt
}
# CONDITIONS
condition.info <- lapply(cond.trigger.list, FUN = function(x) {
event.info$values[which(event.info$values %in% x)]
})
bioware.dt[, names(condition.info) := condition.info]
bioware.dt
tmp.ind <- which(event.info$values %in% respone.trigger)
response.info <- list(onset = event.info$onset[tmp.ind-1])
response.info$offset <- event.info$onset[tmp.ind] - 1
length(tmp.ind)
n.missing <- num.trials - length(tmp.ind)
tmp.ind2 <- which(event.info$values %in% start.trigger)
tmp.ind2
diff(tmp.ind2)
tmp.diff <- c(diff(tmp.ind2), NaN)
tmp.fail <- unique(sort(tmp.diff))[which(table(tmp.diff)==n.missing)]
tmp.fail.ind <- which(tmp.diff==tmp.fail)
bioware.dt[-tmp.fail.ind, response := event.info$values[tmp.ind]]
bioware.dt[-tmp.fail.ind, rt := (response.info$offset - response.info$onset)/samp.factor]
bioware.dt
final.dt.psypy$button_resp.corr
final.dt.psypy$button_resp.rt
tmp.diff <- c(diff(tmp.ind2), NaN)
tmp.fail <- unique(sort(tmp.diff))[which(table(tmp.diff)==n.missing)]
tmp.fail
tmp.diff
tmp.fail.ind <- which(tmp.diff==tmp.fail)
tmp.fail.ind
# PREPARE FILENAMES
length.fn <- length(filenames)
fn.info <- extract_info_fn(filenames)
order.fn <- 1:length.fn
if (sort) {
order.fn <- order(fn.info$subjNR, fn.info$blockNR)
filenames <- filenames[order.fn]
if (length(n.trials) > 1) {
n.trials <- n.trials[order.fn]
} else {
n.trials <- rep(n.trials, length.fn)
}
setorder(fn.info, subjNR, blockNR)
}
# CREATE SOME CONSTANT OBJECTS
samp.factor <- sampling.freq/1000
cols <- c("Fx", "Fy", "Mx", "My", "Mz", "CoPx", "CoPy")
colsnew <- paste0(cols, "_bc")
# LIST (OF DATA.TABLE OBJECTS) CONTAINING ALL SUBJECTS AND BLOCKS
list.bioware.dt <- list()
for (i in 1:length.fn) {
num.trials <- n.trials[i]
# READ IN FILE BY NAME (AND GET PORT INDICES)
port.ind <- NULL
tmp.col.names <- NULL
if (is.null(col.names)){
tmp.col.names <- colnames(fread(filenames[i], skip = skip-2, nrows = 1))
if(any(tmp.col.names == "aux")) {
port.ind <- which(tmp.col.names == "aux")
tmp.col.names[port.ind] <- paste0("port", 1:length(port.ind))
}
}
tmp.dt <- fread(filenames[i], na.strings = na.strings, skip = skip, col.names = tmp.col.names)
# COMPUTE SOME VARIABLES
tmp.dt[, CoPx:=(Fx*az0 - My*1000)/(Fz)]
tmp.dt[, CoPy:=(Fy*az0 + Mx*1000)/(Fz)]
tmp.dt[, Tz_new:=(Mz)*1000 - (Fy)*(CoPx) + (Fx)*(CoPy)]
# CALCULATE EVENTS BY TRANSFORMATION OF PORT AND BYTE TO DECIMAL
byte <- tmp.dt[, lapply(.SD, function(x) x > 1.5), .SDcols = port.ind]
tmp.dt[, events := event_encoder(byte = byte, port.ind = port.ind)]
rm(byte); gc()
# PREPARE CONDITIONS FOR BIOWARE DATA.TABLE
cond.names <- names(cond.trigger.list)
# CREATE DATA.TABLE FOR THE CURRENT BLOCK
bioware.dt <- data.table(subj = fn.info$subjNR[i], block = fn.info$blockNR[i],
trial = 1:num.trials, bioware = list())
bioware.dt[, c(cond.names) := .(NA)]
bioware.dt <- bioware.dt[, c(1:3, 4+(1:length(cond.names)), 4), with = FALSE]
# CREATE LIST FOR DATA.TABLE OBJECTS PER TRIAL
bioware.trial.list <- vector(mode = "list", length = num.trials)
# CREATE ON- AND OFFSETS FOR EACH TRIGGER AND CLEAN
event.info <- event_transcription(dt = tmp.dt)
# PREPARE SEGMENTATION
tmp.ind <- which(event.info$values %in% start.trigger)
trial.info <- list(onset = event.info$onset[tmp.ind] - round(samp.factor*start.prepend))
trial.info$offset <- c(tail(trial.info$onset, -1), nrow(tmp.dt))
trial.ind <- vec_seq(trial.info$onset, trial.info$offset, 1)
for (j in 1:length(trial.ind)) {
tmp.trial.dt <- copy(tmp.dt[trial.ind[[j]]])
bioware.trial.list[[j]] <- tmp.trial.dt
}
# CONDITIONS
condition.info <- lapply(cond.trigger.list, FUN = function(x) {
event.info$values[which(event.info$values %in% x)]
})
bioware.dt[, names(condition.info) := condition.info]
# RESPONSE AND RESPONSE TIME
# --- # --- # assuming usually all trials have the same number of triggers in it
tmp.ind <- which(event.info$values %in% respone.trigger)
response.info <- list(onset = event.info$onset[tmp.ind-1])
response.info$offset <- event.info$onset[tmp.ind] - 1
if (length(tmp.ind) == num.trials) {
bioware.dt[, response := event.info$values[tmp.ind]]
bioware.dt[, rt := (response.info$offset - response.info$onset)/samp.factor]
} else {
n.missing <- num.trials - length(tmp.ind)
tmp.ind2 <- which(event.info$values %in% start.trigger)
tmp.diff <- c(diff(tmp.ind2), NaN)
tmp.fail <- unique(sort(tmp.diff))[which(table(tmp.diff)==n.missing)]
tmp.fail.ind <- which(tmp.diff==tmp.fail)
bioware.dt[-tmp.fail.ind, response := event.info$values[tmp.ind]]
bioware.dt[-tmp.fail.ind, rt := (response.info$offset - response.info$onset)/samp.factor]
}
# BASELINE CORRECTION
if (baseline.trigger >= 1) {
tmp.ind <- which(event.info$values %in% baseline.trigger)
baseline.info <- list(zero = event.info$onset[tmp.ind])
if (is.null(baseline.intv)) {
baseline.info$lower <- baseline.info$zero
baseline.info$upper <- event.info$onset[tmp.ind+1] - 1
} else {
baseline.info$lower <- baseline.info$zero + round(samp.factor*baseline.intv[1])
baseline.info$upper <- baseline.info$zero + round(samp.factor*baseline.intv[2])
}
baseline.ind <- vec_seq(baseline.info$lower, baseline.info$upper, 1)
crossings <- unique(tmp.dt$events[unlist(baseline.ind)])
if (any(!(crossings %in% c(0, baseline.trigger)))) {
warning(paste0("when using the baseline.intv the following triggers were crossed: ", paste0(crossings[which(!(crossings %in% c(0, baseline.trigger)))], collapse = ", ")))
}
means <- lapply(baseline.ind, function(rows) {
tmp.dt[rows, lapply(.SD, mean), .SDcols = cols]
})
meansdiff <- lapply(baseline.ind, function(rows) {
tmp.dt[rows, lapply(.SD, FUN = function(x) mean(diff(x))), .SDcols = c("CoPx", "CoPy")]
})
for (j in 1:length(trial.ind)) {
bioware.trial.list[[j]][, c("dCoPx", "dCoPy") := .(c(diff(CoPx), NaN), c(diff(CoPy), NaN))]
bioware.trial.list[[j]][, c("dCoPx", "dCoPy") := .(dCoPx - meansdiff[[j]]$CoPx, dCoPy - meansdiff[[j]]$CoPy)]
bioware.trial.list[[j]][, c("Fx", "Fy", "Mx", "My", "Mz", "CoPx", "CoPy") := .(Fx - means[[j]]$Fx, Fy - means[[j]]$Fy,
Mx - means[[j]]$Mx, My - means[[j]]$My, Mz - means[[j]]$Mz,
CoPx - means[[j]]$CoPx, CoPy - means[[j]]$CoPy)]
setnames(bioware.trial.list[[j]], c(cols, "dCoPx", "dCoPy"), c(colsnew, "dCoPx_bc", "dCoPy_bc"))
bioware.dt$bioware[[j]] <- bioware.trial.list[[j]]
}
}
# TIME LOCKING
# NOTE: just calculate for each trial how many data points need to
#   be before and after such that the time lock is at the
#   desired location
# NOTE2: maybe take bioware.trial.list and change that
#   and then add all to bioware.dt
# SAVE DATA.TABLE IN LARGE A LIST
list.bioware.dt[[i]] <- bioware.dt
}
bw.dt <- rbindlist(list.bioware.dt)
data.frame(bw.dt$rt, final.dt.psypy$button_resp.rt*1000)
mean(bw.dt$rt - final.dt.psypy$button_resp.rt*1000)
mean(bw.dt$rt - final.dt.psypy$button_resp.rt*1000, na.rm = TRUE)
hist(bw.dt$rt - final.dt.psypy$button_resp.rt*1000, na.rm = TRUE)
hist(bw.dt$rt - final.dt.psypy$button_resp.rt*1000)
hist(bw.dt$rt - final.dt.psypy$button_resp.rt*1000, na.rm = TRUE)
hist(bw.dt$rt - final.dt.psypy$button_resp.rt*1000, na.rm = TRUE)
bw.dt
bioware.dt$bioware[[1]]
# CREATE ON- AND OFFSETS FOR EACH TRIGGER AND CLEAN
event.info <- event_transcription(dt = bioware.dt$bioware[[1]])
event.info
devtools::load_all(".")
devtools::load_all(".")
# CREATE ON- AND OFFSETS FOR EACH TRIGGER AND CLEAN
event.info <- event_transcription(dt = bioware.dt$bioware[[1]], correction = FALSE)
event.info
bioware.dt$bioware[[1]]
bioware.dt$bioware[[1]]
event.info$offsets
bioware.dt$bioware[[2]]
bioware.dt$bioware[[3]]
event.info$offsets
bioware.dt$bioware[[80]]
length.fn <- length(filenames)
fn.info <- extract_info_fn(filenames)
order.fn <- 1:length.fn
if (sort) {
order.fn <- order(fn.info$subjNR, fn.info$blockNR)
filenames <- filenames[order.fn]
if (length(n.trials) > 1) {
n.trials <- n.trials[order.fn]
} else {
n.trials <- rep(n.trials, length.fn)
}
setorder(fn.info, subjNR, blockNR)
}
# CREATE SOME CONSTANT OBJECTS
samp.factor <- sampling.freq/1000
cols <- c("Fx", "Fy", "Mx", "My", "Mz", "CoPx", "CoPy")
colsnew <- paste0(cols, "_bc")
# LIST (OF DATA.TABLE OBJECTS) CONTAINING ALL SUBJECTS AND BLOCKS
list.bioware.dt <- list()
for (i in 1:length.fn) {
num.trials <- n.trials[i]
# READ IN FILE BY NAME (AND GET PORT INDICES)
port.ind <- NULL
tmp.col.names <- NULL
if (is.null(col.names)){
tmp.col.names <- colnames(fread(filenames[i], skip = skip-2, nrows = 1))
if(any(tmp.col.names == "aux")) {
port.ind <- which(tmp.col.names == "aux")
tmp.col.names[port.ind] <- paste0("port", 1:length(port.ind))
}
}
tmp.dt <- fread(filenames[i], na.strings = na.strings, skip = skip, col.names = tmp.col.names)
# COMPUTE SOME VARIABLES
tmp.dt[, CoPx:=(Fx*az0 - My*1000)/(Fz)]
tmp.dt[, CoPy:=(Fy*az0 + Mx*1000)/(Fz)]
tmp.dt[, Tz_new:=(Mz)*1000 - (Fy)*(CoPx) + (Fx)*(CoPy)]
# CALCULATE EVENTS BY TRANSFORMATION OF PORT AND BYTE TO DECIMAL
byte <- tmp.dt[, lapply(.SD, function(x) x > 1.5), .SDcols = port.ind]
tmp.dt[, events := event_encoder(byte = byte, port.ind = port.ind)]
rm(byte); gc()
# PREPARE CONDITIONS FOR BIOWARE DATA.TABLE
cond.names <- names(cond.trigger.list)
# CREATE DATA.TABLE FOR THE CURRENT BLOCK
bioware.dt <- data.table(subj = fn.info$subjNR[i], block = fn.info$blockNR[i],
trial = 1:num.trials, bioware = list())
bioware.dt[, c(cond.names) := .(NA)]
bioware.dt <- bioware.dt[, c(1:3, 4+(1:length(cond.names)), 4), with = FALSE]
# CREATE LIST FOR DATA.TABLE OBJECTS PER TRIAL
bioware.trial.list <- vector(mode = "list", length = num.trials)
# CREATE ON- AND OFFSETS FOR EACH TRIGGER AND CLEAN
event.info <- event_transcription(dt = tmp.dt)
# PREPARE SEGMENTATION
tmp.ind <- which(event.info$values %in% start.trigger)
trial.info <- list(onset = event.info$onset[tmp.ind] - round(samp.factor*start.prepend))
trial.info$offset <- c(tail(trial.info$onset-1, -1), nrow(tmp.dt))
trial.ind <- vec_seq(trial.info$onset, trial.info$offset, 1)
for (j in 1:length(trial.ind)) {
# tmp.trial.dt <- copy(tmp.dt[trial.ind[[j]]])
bioware.trial.list[[j]] <- copy(tmp.dt[trial.ind[[j]]])
}
# CONDITIONS
condition.info <- lapply(cond.trigger.list, FUN = function(x) {
event.info$values[which(event.info$values %in% x)]
})
bioware.dt[, names(condition.info) := condition.info]
# RESPONSE AND RESPONSE TIME
# --- # --- # assuming usually all trials have the same number of triggers in it
tmp.ind <- which(event.info$values %in% respone.trigger)
response.info <- list(onset = event.info$onset[tmp.ind-1])
response.info$offset <- event.info$onset[tmp.ind] - 1
if (length(tmp.ind) == num.trials) {
bioware.dt[, response := event.info$values[tmp.ind]]
bioware.dt[, rt := (response.info$offset - response.info$onset)/samp.factor]
} else {
n.missing <- num.trials - length(tmp.ind)
tmp.ind2 <- which(event.info$values %in% start.trigger)
tmp.diff <- c(diff(tmp.ind2), NaN)
tmp.fail <- unique(sort(tmp.diff))[which(table(tmp.diff)==n.missing)]
tmp.fail.ind <- which(tmp.diff==tmp.fail)
bioware.dt[-tmp.fail.ind, response := event.info$values[tmp.ind]]
bioware.dt[-tmp.fail.ind, rt := (response.info$offset - response.info$onset)/samp.factor]
}
# BASELINE CORRECTION
if (baseline.trigger >= 1) {
tmp.ind <- which(event.info$values %in% baseline.trigger)
baseline.info <- list(zero = event.info$onset[tmp.ind])
if (is.null(baseline.intv)) {
baseline.info$lower <- baseline.info$zero
baseline.info$upper <- event.info$onset[tmp.ind+1] - 1
} else {
baseline.info$lower <- baseline.info$zero + round(samp.factor*baseline.intv[1])
baseline.info$upper <- baseline.info$zero + round(samp.factor*baseline.intv[2])
}
baseline.ind <- vec_seq(baseline.info$lower, baseline.info$upper, 1)
crossings <- unique(tmp.dt$events[unlist(baseline.ind)])
if (any(!(crossings %in% c(0, baseline.trigger)))) {
warning(paste0("when using the baseline.intv the following triggers were crossed: ", paste0(crossings[which(!(crossings %in% c(0, baseline.trigger)))], collapse = ", ")))
}
means <- lapply(baseline.ind, function(rows) {
tmp.dt[rows, lapply(.SD, mean), .SDcols = cols]
})
meansdiff <- lapply(baseline.ind, function(rows) {
tmp.dt[rows, lapply(.SD, FUN = function(x) mean(diff(x))), .SDcols = c("CoPx", "CoPy")]
})
for (j in 1:length(trial.ind)) {
bioware.trial.list[[j]][, c("dCoPx", "dCoPy") := .(c(diff(CoPx), NaN), c(diff(CoPy), NaN))]
bioware.trial.list[[j]][, c("dCoPx", "dCoPy") := .(dCoPx - meansdiff[[j]]$CoPx, dCoPy - meansdiff[[j]]$CoPy)]
bioware.trial.list[[j]][, c("Fx", "Fy", "Mx", "My", "Mz", "CoPx", "CoPy") := .(Fx - means[[j]]$Fx, Fy - means[[j]]$Fy,
Mx - means[[j]]$Mx, My - means[[j]]$My, Mz - means[[j]]$Mz,
CoPx - means[[j]]$CoPx, CoPy - means[[j]]$CoPy)]
setnames(bioware.trial.list[[j]], c(cols, "dCoPx", "dCoPy"), c(colsnew, "dCoPx_bc", "dCoPy_bc"))
bioware.dt$bioware[[j]] <- bioware.trial.list[[j]]
}
}
# TIME LOCKING
# NOTE: just calculate for each trial how many data points need to
#   be before and after such that the time lock is at the
#   desired location
# NOTE2: maybe take bioware.trial.list and change that
#   and then add all to bioware.dt
# SAVE DATA.TABLE IN LARGE A LIST
list.bioware.dt[[i]] <- bioware.dt
}
bw.dt <- rbindlist(list.bioware.dt)
bw.dt$bioware[[1]]
bioware.dt <- bw.dt
nrow(bioware.dt)
i=1
event.info2 <- event_transcription(dt = bioware.dt$bioware[[i]], correction = FALSE)
event.info2
event.info
# CREATE ON- AND OFFSETS FOR EACH TRIGGER AND CLEAN
event.info <- event_transcription(dt = bioware.dt$bioware[[i]], correction = FALSE)
event.info
time.lock.trigger = c(2,4, 8,16)
time.lock.intv = c(-100, 100)
# CREATE ON- AND OFFSETS FOR EACH TRIGGER AND CLEAN
event.info <- event_transcription(dt = bioware.dt$bioware[[i]], correction = FALSE)
tmp.ind <- which(event.info$values %in% time.lock.trigger)
lock.info <- list(zero = event.info$onset[tmp.ind])
if (is.null(time.lock.intv)) {
lock.info$lower <- lock.info$zero
lock.info$upper <- event.info$onset[tmp.ind+1] - 1
} else {
lock.info$lower <- lock.info$zero + round(samp.factor*time.lock.intv[1])
lock.info$upper <- lock.info$zero + round(samp.factor*time.lock.intv[2])
}
lock.info
lock.ind <- seq(lock.info$lower, lock.info$upper, 1)
lock.ind
crossings <- unique(tmp.dt$events[unlist(baseline.ind)])
crossings
if (any(!(crossings %in% c(0, baseline.trigger)))) {
warning(paste0("when using the baseline.intv the following triggers were crossed: ", paste0(crossings[which(!(crossings %in% c(0, baseline.trigger)))], collapse = ", ")))
}
12%% 3
12%% 5
c(12, 10) %% 5
any(c(12, 10) %% 5 != 0)
any(c(12, 8) %% 4 != 0)
any(c(12, 8) %% 5 != 0)
is.vector(list(a=1, b=23))
is.list(c(1,23))
list(c(1,23))
list(f1 = function(x) {x+2}, f2 = function(x) {x^2})
bla <- list(f1 = function(x) {x+2}, f2 = function(x) {x^2})
bla$f1(2)
bla[[1]](2)
bla <- list(f1 = function(x) {x+2}, f2 = function(x) {x^2}, f3 = mean)
bla$f3(c(1,3))
